---
title: "volcano3D Vignette"
author: "Katriona Goldmann"
output: rmarkdown::html_vignette
toc:
  depth: 5
vignette: >
  \VignetteIndexEntry{volcano3D Package}
  \VignetteEngine{knitr::knitr}
  \usepackage[utf8]{inputenc}
---

```{r setup, include = FALSE, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      warning = FALSE, 
                      message = FALSE, 
                      fig.align = 'center',
                      dev.args=list(bg="transparent")
)


library(knitr)
library(kableExtra)
source("https://gist.githubusercontent.com/KatrionaGoldmann/3d6dfd6aa4cc5c3940bb72dc49beae02/raw/26e78c78a7a9d096d695c708e8a45830a1d1121a/render_toc.R")
```

<img src="../logo.png" align="right" alt="" width="200" style="border: 0; margin: 5px;" />

# Introduction 

The volcano3D package enables exploration of probes differentially 
expressed between three groups. Its main purpose is for the
visualisation of differentially expressed genes in a three-dimensional
volcano plot. These plots can be converted to interactive visualisations using
[plotly](https://plot.ly/r/). 

This vignette consists of a case study from the PEAC 
rheumatoid arthritis project (Pathobiology of Early Arthritis Cohort). 
The methodology has been published in 
[Lewis, Myles J., et al. 'Molecular portraits of early rheumatoid arthritis 
identify clinical and treatment response phenotypes.' Cell reports 28.9 (2019): 
2455-2470.
(DOI: 10.1016/j.celrep.2019.07.091)](https://doi.org/10.1016/j.celrep.2019.07.091)
with an interactive web tool available at 
[https://peac.hpc.qmul.ac.uk](https://peac.hpc.qmul.ac.uk).  

There are also supplementary vignettes with further information on:

- [using the volcano3D package to create and deploy a shiny app](https://katrionagoldmann.github.io/volcano3D/articles/shiny_builder.html)

## Getting Started

### Prerequisites

* [ggplot2](https://CRAN.R-project.org/package=ggplot2)
* [ggpubr](https://CRAN.R-project.org/package=ggpubr)
* [plotly](https://CRAN.R-project.org/package=plotly)

### Install from CRAN

[![CRAN status](https://www.r-pkg.org/badges/version/volcano3D)](https://cran.r-project.org/package=volcano3D)

```{r, eval = FALSE}
install.packages("volcano3D")
```

### Install from Github

[![GitHub tag](https://img.shields.io/github/tag/KatrionaGoldmann/volcano3D.svg)](https://GitHub.com/KatrionaGoldmann/volcano3D/tags/)

```{r, eval = FALSE}
library(devtools)
install_github("KatrionaGoldmann/volcano3D")
```

### Load the package

```{r}
library(volcano3D)
```

```{r, echo=FALSE}
library(ggpubr)
library(plotly)
```


# Example 1. Synovial Gene Data

This vignette will demonstrate the power of this package using a basic example
from the [PEAC data set](http://www.peac-mrc.mds.qmul.ac.uk). Here we will focus
on the synovial data from this cohort.

Using the synovial biopsies from PEAC we can create a polar object for
differentially expressed genes. The sample data used in this vignette can be 
loaded from the [volcano3Ddata package](https://github.com/KatrionaGoldmann/volcano3Ddata). 


```{r, eval=FALSE}
devtools::install_github("KatrionaGoldmann/volcano3Ddata")
library(volcano3Ddata)
data("syn_data")
```

```{r, echo=FALSE}
library(volcano3Ddata)
data("syn_data")
```

Samples in this cohort fall into three pathotype groups: 

```{r}
kable(table(syn_metadata$Pathotype), col.names = c("Pathotype", "Count"))
```

In this example we are interested in genes that are differentially expressed 
between each of these groups. 

The differential expression can be mapped to polar coordinates using the
polar_coords function, which has inputs:

```{r, echo=FALSE}
mytable = data.frame(
  outcome = c("outcome\ 
  \n\n(required)", 
  "Vector containing three-level factor indicating which of the three classes each sample belongs to."), 
  data = c("data\ 
              \n\n(required)", 
          "A dataframe or matrix containing data to be compared between the three classes (e.g. gene expression data). Note that variables are in columns, so gene expression data will need to be transposed. This \
           is used to calculate z-score and fold change, so for gene expression count data it should be \
           normalised such as log transformed or variance stabilised count transformation."),
  pvals = c("pvals\ 
              \n\n(optional)", 
              "the pvals matrix which contains the statistical\
                significance of probes or attributes between classes. This contains: \
              \n * the first column is a group test such as one-way ANOVA or Kruskal-Wallis test.
              \n * columns 2-4 contain p-values one for each comparison in the sequence A vs B, A vs C, B vs C, where A, B, C are the three levels in sequence in the outcome factor.
              For gene expression RNA-Seq count data, conduit functions
              using 'limma voom' or 'DESeq' pipelines to extract p-values for \
              analysis are provided in functions `deseq_polar()` and `voom_polar()`.\ 
              If p-values are not provided by the user, they can be calculated via the `polar_coords()` function.
              "),
  padj = c("padj\ 
              \n\n(optional)", 
              "Matrix containing the adjusted p-values matching the pvals matrix."),
  
  pcutoff = c("pcutoff", "Cut-off for p-value significance"),
  scheme = c("scheme", "Vector of colours starting with non-significant attributes"),
  labs = c("labs", 'Optional character vector for labelling classes. Default `NULL`
   leads to abbreviated labels based on levels in `outcome` using
   `abbreviate()`. A vector of length 3 with custom abbreviated names for the
   outcome levels can be supplied. Otherwise a vector length 7 is expected, of
   the form "ns", "B+", "B+C+", "C+", "A+C+", "A+", "A+B+", where "ns" means
   non-significant and A, B, C refer to levels 1, 2, 3 in `outcome`, and must
   be in the correct order.')
  
)

kable(t(mytable), row.names = FALSE, col.names = c("Variable", "Details")) %>%
  kable_styling(font_size=11)
```

The `polar_coords()` function can be used to map any multi-dimensional data
where you are comparing 3 classes. The function will perform statistical
analysis comparing each column or attribute against the three classes using a
group test which can either be a one-way ANOVA or Kruskal-Wallis test. Then it
will perform pairwise comparisons of the three groups. Alternatively a table of
p-values can be supplied by the user.

For researchers investigating RNA-Seq gene expression data, the package provides
2 easy to pipeline functions which enable analysis of count data via the
Bioconductor packages 'DESeq2' or 'limma voom'.

Thus we can map the PEAC data to polar coordinates using the `deseq_polar()` 
function.

```{r eval=FALSE}
library(DESeq2)
library(volcano3Ddata)
data("syn_txi")

syn_metadata$Pathotype <- factor(syn_metadata$Pathotype, 
                                 levels = c('Lymphoid', 'Myeloid', 'Fibroid'))
# setup initial dataset from Tximport
dds <- DESeqDataSetFromTximport(txi = syn_txi, 
                                colData = syn_metadata, 
                                design = ~ Pathotype + Batch + Gender)
# initial analysis run
dds_DE <- DESeq(dds)
# likelihood ratio test on 'Pathotype'
dds_LRT <- DESeq(dds, test = "LRT", reduced = ~ Batch + Gender, parallel = TRUE)

# create 'volc3d' class object for plotting
res <- deseq_polar(dds_DE, dds_LRT, "Pathotype")

# plot 3d volcano plot
volcano3D(res)
```

An alternative method is to use the `voom_polar()` function which uses the
'limma voom' RNA-Seq analysis pipeline.

```{r eval = FALSE}
library(limma)
library(edgeR)

data("syn_txi")
syn_tpm <- syn_txi$counts
syn_tpm <- syn_tpm[!duplicated(rownames(syn_tpm)), ]

# create 'volc3d' class object for plotting
resl <- voom_polar(~0 + Pathotype + Batch + Gender, syn_metadata, syn_tpm)

# plot 3d volcano plot
volcano3D(resl)
```

Finally we show how you can manually provide data (ideally normally distributed)
to generate a 'volc3d' object for plotting using the `polar_coords()` function.
If the argument `pvals` is not supplied, then `polar_coords` will calculate
p-values for the group test (either one-way ANOVA or Kruskal-Wallis test) and
pairwise tests (t-test or Wilcoxon test). Alternatively the user can provide a
matrix of p-values using their own statistical method.

```{r}
# Place Pathotype levels in correct sequence
syn_metadata$Pathotype <- factor(syn_metadata$Pathotype, 
                                 levels = c('Lymphoid', 'Myeloid', 'Fibroid'))

syn_polar <- polar_coords(outcome = syn_metadata$Pathotype,
                          data = t(syn_rld))
```

This creates a 'volc3d' S4 class object with slots for: `df`, `outcome`, `data`,
`pvals` and `padj`. The `df` slot is a list of 2 dataframes. The first dataframe
contains polar coordinates for scaled data, while the 2nd dataframe has polar
coordinates for unscaled data. In gene expression data which is log2
transformed, the polar scale for the 2nd dataframe equates to log2 fold change.

The `lab` column in `syn_polar@df[[1]]` allows us to determine relative
differences in expression between groups (in this case pathotypes). The '+'
indicates which pathotypes are significantly 'up' compared to others. For
example:

* genes labelled 'L+' are significantly up in Lymphoid vs
other groups

* genes up in two pathotypes such as 'L+M+' are up in both
Lymphoid **and** Myeloid, therefore Lymphoid vs
Fibroid and Myeloid vs Fibroid are statistically significant.

* genes which show no significant difference between pathotypes are classed
as `ns`

This gives us:

```{r, eval=FALSE}
setNames(data.frame(table(syn_polar@df[[1]]$lab)), c("Significance", "Frequency"))
```

```{r, echo=FALSE}
table(syn_polar@df[[1]]$lab) %>%
  kable(col.names = c("Significance", "Frequency")) %>%
  kable_styling(full_width = F)
```

To subset and view objects of specific significance groups you can use the 
`significance_subset` function. 

```{r}
pvals_subset <- significance_subset(syn_polar, 
                                    significance = c("L+", "M+"), 
                                    output="pvals")

polar_subset <- significance_subset(syn_polar, 
                                    significance = c("L+", "M+"), 
                                    output="polar")

head(pvals_subset) %>%
  kable() %>%
  kable_styling(full_width = F)
```


## Radial Plots

The differential expression can now be visualised on an interactive radar plot
using radial_plotly. The `labelRows` argument allows genes/ attributes of
interest to be labelled:

```{r, out.height="100%", out.width="100%"}
radial_plotly(polar = syn_polar, 
              label_rows = c("SLAMF6", "PARP16", "ITM2C"), 
              hover=hovertext)
```

By hovering over certain points you can also determine genes for future
interrogation.

Similarly we can create a static ggplot image using `radial_ggplot`:

```{r, fig.height=4.5, fig.width=7}
radial_ggplot(polar = syn_polar,
              label_rows = c("SLAMF6", "FMOD"),
              marker_size = 2.3,
              legend_size = 10) +
  theme(legend.position = "right")
```

## Boxplots

We can then interrogate any one specific variable as a boxplot, to investigate
these differences. This is build using either ggplot2 or plotly so can easily be edited by the
user to add features. Using plotly:

```{r, fig.height = 3.7, fig.width=9}
plot1 <- boxplot_trio(syn_polar,
                      value = "FAM92B",
                      text_size = 7,
                      test = "polar_padj",
                      levels_order = c("Lymphoid", "Myeloid", "Fibroid"),
                      box_colours = c("blue", "red", "green3"),
                      step_increase = 0.2,
                      plot_method='plotly')

plot2 <- boxplot_trio(syn_polar,
                      value = "SLAMF6",
                      text_size = 7,
                      test = "polar_multi_pvalue",
                      levels_order = c("Lymphoid", "Myeloid", "Fibroid"),
                      box_colours = c("blue", "red", "green3"), 
                      plot_method='plotly') 

plot3 <- boxplot_trio(syn_polar,
                      value = "PARP16",
                      text_size = 7,
                      stat_size=2.5,
                      test = "t.test",
                      levels_order = c("Myeloid", "Fibroid"),
                      box_colours = c("pink", "gold"), 
                      plot_method='plotly') 

plotly::subplot(plot1, plot2, plot3, titleY=TRUE, margin=0.05)
```

Or using ggplot

```{r, fig.height = 3.2, fig.width=7}
plot1 <- boxplot_trio(syn_polar,
                      value = "FAM92B",
                      text_size = 7,
                      test = "polar_pvalue",
                      levels_order = c("Lymphoid", "Myeloid", "Fibroid"),
                      box_colours = c("blue", "red", "green3"),
                      step_increase = 0.1)

plot2 <- boxplot_trio(syn_polar,
                      value = "SLAMF6",
                      text_size = 7,
                      test = "polar_multi_pvalue",
                      levels_order = c("Lymphoid", "Myeloid", "Fibroid"),
                      box_colours = c("blue", "red", "green3")) 

plot3 <- boxplot_trio(syn_polar,
                      value = "PARP16",
                      text_size = 7,
                      stat_size=2.5,
                      test = "t.test",
                      levels_order = c("Myeloid", "Fibroid"),
                      box_colours = c("pink", "gold")) 

ggarrange(plot1, plot2, plot3, ncol=3)
```

## Three Dimensional Volcano Plots

The final thing we can look at is the 3D volcano plot which projects
differential gene expression onto cylindrical coordinates.

```{r, fig.width=7}
p <- volcano3D(syn_polar,
               label_rows = c("SLAMF6", "PARP16", "ITM2C"),
               label_size = 10,
               height = 500)

p
```


## Rotating plots

In order to rotate/spin your 3D volcano plot you can use the `add_animation` function. This adds a button to the plotly modeBar (hover top right) which allows you to rotate the plot. 

```{r, fig.width=7}
add_animation(p)
```


# Saving Plotly Plots

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


## Static Images

There are a few ways to save plotly plots as static images. Firstly plotly 
offers a download button ( <i class="fa fa-camera" aria-hidden="true"></i> ) in the figure mode bar (appears top right). 
By default this saves images as png, however it is possible to convert to svg, jpeg or webp using:

```{r, eval=FALSE}
p %>% plotly::config(toImageButtonOptions = list(format = "svg"))
```

## Interactive HTML

The full plotly objects can be saved to HTML by converting them to widgets and 
saving with the htmlwidgets package: 

```{r, eval=FALSE}
htmlwidgets::saveWidget(as_widget(p), "volcano3D.html")
```


# Altering the Plots

## Altering the Grid

By default volcano3D generates a grid using 12 spokes. If you wish to override
any of these variables it is possible to pass in your own grid. This is also
possible for the 3D radial plots where the z elements can be left as NULL.

By manually creating a grid object it is possible to change the tick points on
axes as well as the number of radial spokes (n_spokes). The default ticks are calculated from r_vector and z_vector using the
`pretty` function. This can be overwritten by passing tick points in
r_axis_ticks and z_axis_ticks.

For example, we can decrease the number of radial spokes to 4, while altering the z axis ticks:

```{r}
four_grid = polar_grid(r_vector=syn_polar@df[[1]]$r,
                       z_vector=syn_polar@df[[1]]$z,
                       r_axis_ticks = NULL,
                       axes_from_origin = FALSE, 
                       z_axis_ticks = c(0, 8, 16, 32),
                       n_spokes = 4)
```

We can inspect the grid using `show_grid()` which creates both the polar and 
cylindrical coordinate system:

```{r, fig.width=7}
p <- show_grid(four_grid)

p$cylindrical
```

and pass it into the plotting functions:

```{r, fig.width=7, eval=FALSE}
volcano3D(syn_polar,
          grid = four_grid,
          label_rows = c("SLAMF6", "PARP16", "ITM2C"),
          label_size = 10)
```

For example to extend the radial axis and increase the number of spokes in 2D
we can apply:

```{r, fig.height=5, fig.widht=5}
new_grid = polar_grid(r_vector=NULL,
                      z_vector=syn_polar@df[[1]]$z,
                      r_axis_ticks = c(1, 2, 3),
                      z_axis_ticks = NULL,
                      n_spokes = 24)
```

## Altering the Annotations

To amend or reposition the plotly labels it is possible to use the editable parameter. 
This allows you to move annotation features (labels), change text including 
legends and titles. Click on a feature to change it:

```{r, fig.height=4.5, fig.width=7, eval=FALSE}
p = radial_plotly(polar = syn_polar, 
                  label_rows = c("SLAMF6", "PARP16", "ITM2C"))

p %>% config(editable = TRUE)
```

# Example 2. Synovial Modular Data

We can collapse this example into a modular analysis using a list of gene sets.
In this example we have used the blood transcript modules curated by Li et. al.
in ['Li, S., Rouphael, N., Duraisingham, S., Romero-Steiner, S., Presnell, S.,
Davis, C., ... & Kasturi, S. (2014). Molecular signatures of antibody responses
derived from a systems biology study of five human vaccines. Nature immunology,
15(2), 195.'](https://www.nature.com/ni/journal/v15/n2/abs/ni.2789.html). The
pvalues were generated using
[QuSAGE methodology](http://clip.med.yale.edu/qusage/).

## Creating polar coordinates

The modular analysis can be loaded through Li_pvalues:

```{r}
data(Li_pvalues)

syn_mod_polar <- polar_coords(outcome = syn_metadata$Pathotype,
                              data = t(syn_mod))
```

## Radial Plots


```{r, out.height="100%", out.width="90%", fig.height=8, eval=FALSE, fig.width=10}
radial_plotly(polar = syn_mod_polar,
              axes_from_origin = FALSE, 
              label_rows = c("M156.0", "M37.2"))
```

Or a ggplot static image using radial_ggplot:

```{r, warning = FALSE, fig.height=4.5, fig.width=7}
radial_ggplot(polar = syn_mod_polar,
              label_rows = c("M156.0", "M37.2"),
              marker_size = 2.7,
              label_size = 5,
              axis_lab_size = 3,
              axis_title_size = 5,
              legend_size = 10) 
```

## Boxplots

We can then interrogate specific modules with boxplot_trio:

```{r, fig.height = 2.8, fig.width=5}
plot1 <- boxplot_trio(syn_mod_polar,
                      value = "M156.0",
                      test = "wilcox.test",
                      levels_order = c("Lymphoid", "Myeloid", "Fibroid"),
                      box_colours = c("blue", "red", "green3"))

plot2 <- boxplot_trio(syn_mod_polar,
                      value = "M37.2",
                      test = "wilcox.test",
                      levels_order = c("Lymphoid", "Myeloid", "Fibroid"),
                      box_colours = c("blue", "red", "green3"))

ggpubr::ggarrange(plot1, plot2)
```

---

# Citation

If you use this package please cite as:

```{r}
citation("volcano3D")
```

or using:

> Lewis, Myles J., et al. 'Molecular portraits of early rheumatoid arthritis
identify clinical and treatment response phenotypes.' Cell reports 28.9 (2019):
2455-2470.


